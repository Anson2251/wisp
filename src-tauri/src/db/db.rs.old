use rusqlite::{params, Connection};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use tauri::{AppHandle, Manager};

#[derive(Debug, Serialize, Deserialize)]
pub enum MessageRole {
	User,
	Assistant,
	System,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
    pub id: String,
    pub text: String,
    pub sender: MessageRole,
    pub timestamp: i64,
}

pub struct Database {
    conn: Connection,
}



impl Database {
	pub const TABLE_NAME: &str = "messages";

    pub fn new(app_handle: &AppHandle) -> Result<Self, rusqlite::Error> {
        let app_dir = app_handle
            .path()
            .app_data_dir()
            .expect("Failed to get app data dir");
        println!("App dir: {:?}", app_dir);
        std::fs::create_dir_all(&app_dir).expect("Failed to create app data dir");
        let db_path = PathBuf::from(app_dir).join("messages.db");

        let conn = Connection::open(db_path)?;
        conn.execute(
            &format!("CREATE TABLE IF NOT EXISTS {} (
                id TEXT PRIMARY KEY,
                text TEXT NOT NULL,
                sender TEXT NOT NULL,
                timestamp INTEGER NOT NULL
            )", Self::TABLE_NAME),
            [],
        )?;

        Ok(Database { conn })
    }

    pub fn save_message(&self, id: &str, text: &str, sender: &str, parent_id: Option<&str>) -> Result<(), rusqlite::Error> {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        self.conn.execute(
            &format!("INSERT INTO {} (id, text, sender, timestamp) VALUES (?1, ?2, ?3, ?4)", Self::TABLE_NAME),
            params![id, text, sender, timestamp],
        )?;
        Ok(())
    }

    pub fn get_messages(&self) -> Result<Vec<Message>, rusqlite::Error> {
        let mut stmt = self
            .conn
            .prepare(&format!("SELECT id, text, sender, timestamp FROM {} ORDER BY timestamp ASC", Self::TABLE_NAME))?;

        let messages = stmt
            .query_map([], |row| {
                Ok(Message {
                    id: row.get(0)?,
                    text: row.get(1)?,
                    sender: match row.get::<_, Option<String>>(2)? {
						Some(s) if s == "user" => MessageRole::User,
						Some(s) if s == "bot" => MessageRole::Assistant,
						Some(s) if s == "system" => MessageRole::System,
						_ => return Err(rusqlite::Error::ToSqlConversionFailure("Unknown message role".into())),
					},
                    timestamp: row.get(3)?,
                })
            })?
            .collect::<Result<Vec<_>, _>>()?;

        Ok(messages)
    }

    pub fn clear_messages(&self) -> Result<(), rusqlite::Error> {
        self.conn.execute("DELETE FROM messages", [])?;
        Ok(())
    }

    pub fn delete_message(&self, id: &str) -> Result<(), rusqlite::Error> {
        self.conn
            .execute("DELETE FROM messages WHERE id = ?1", params![id])?;
        Ok(())
    }
}
